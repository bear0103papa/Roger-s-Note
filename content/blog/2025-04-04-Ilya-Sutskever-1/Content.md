---
layout: post
title: "John McCarthy 回顧人工智慧的普遍性 (1971 圖靈獎演講)"
date: 2024-04-04
categories: [
  'John McCarthy',
  'Artificial Intelligence',
  '1971',
  'Turing Award',
  'Computer Science History',
]
description: ""
toc: true # 啟用目錄功能

---

<span class="original-link">原文連結： [Generality in Artificial Intelligence (1971)](https://dl.acm.org/doi/pdf/10.1145/1283920.1283926)</span>

**本次採訪為1971 JOHN McCARTHY獲得圖靈獎時的演講**

## 後記

我 1971 年的圖靈獎講座題目是「人工智慧的普遍性」。這個主題後來證明過於宏大，因為我發現在當時無法將自己關於這個主題的想法以令人滿意的書面形式表達出來。當時回顧先前的工作會比嘗試新事物更好，但那時我並非習慣如此。我很感謝 ACM 再次給我這個機會。不幸的是對於我們的科學領域，或許幸運的是對於這個項目，人工智慧 (AI) 的普遍性問題幾乎和以前一樣未被解決，儘管我們現在有許多在 1971 年時還沒有的想法。本文在很大程度上依賴於這些想法，但遠非對 1986 年達成普遍性方法的全面調查。討論的想法是以與我對它們的熟悉程度成比例的篇幅來討論，而不是根據某些客觀標準。在 1971 年甚至在 1958 年，AI 程式缺乏普遍性是顯而易見的。現在這仍然顯而易見，並且有更多的細節。第一個明顯的症狀是，對程式概念的一個小增補往往需要從資料結構開始進行徹底的重寫。在模組化資料結構方面已取得一些進展，但對搜尋策略的小修改甚至更不可能在不重寫的情況下完成。另一個症狀是，沒有人知道如何建立一個常識知識的通用資料庫，供任何需要該知識的程式使用。與其他資訊一起，這樣的資料庫將包含一個機器人需要知道的關於移動物體效果的知識，一個人通常被預期知道的關於其家庭的知識，以及關於買賣的事實。這並不取決於知識是以邏輯語言還是其他形式主義來表達。當我們採用邏輯方法處理 AI 時，普遍性的缺乏體現在我們設計用來表達常識知識的公理在其適用性上過於受限，無法用於一個通用的常識資料庫。在我看來，獲得一種用於表達通用常識知識以便納入通用資料庫的語言，是 AI 中普遍性問題的關鍵。以下是一些在 1971 年前後提出的實現普遍性的想法。

我重申我的免責聲明，即這並非全面性的。

## 透過程式表達行為

Friedberg [7, 8] 討論了一種完全通用的表達行為的方式，並提供了一種學習改進的方法。也就是說，行為由計算機程式表示，學習是透過對程式進行隨機修改並測試修改後的程式來完成的。Friedberg 的方法僅成功學習了如何將單個位元從一個記憶體單元移動到另一個記憶體單元，其透過降低參與成功運行的指令的修改機率來獎勵指令的方案，被 Simon [24] 證明不如徹底測試每個程式並完全捨棄任何不完美的程式。似乎沒有人嘗試過跟進透過修改整個程式來學習的想法。Friedberg 方法的缺陷在於，雖然用程式表達行為是完全通用的，但透過對程式進行小修改來修改行為卻非常特殊。對行為的一個小的概念性修改通常不能透過對程式的小修改來表示，特別是如果使用機器語言程式，並且程式文本的任何一個小修改被認為與任何其他修改一樣可能發生。或許值得嘗試一些更類似於基因演化的東西；子程式的副本會被製作出來，一些副本會被修改而其他的保持不變。學習系統接著會實驗將原始子程式的某些呼叫更改為對修改後子程式的呼叫是否有利。很可能即使這樣也行不通，除非行為的相關小修改可以透過呼叫稍微修改過的子程式來獲得。可能需要提供對子程式參數數量的修改。雖然 Friedberg 的問題是從經驗中學習，但所有透過程式表達知識的方案在目標是結合不同知識或製作修改知識的程式時，都會遇到類似的困難。

## 通用問題求解器 (GPS)及其後繼者

AI 中的一種普遍性包括尋找獨立於問題領域的解決方案的方法。Allen Newell, Herbert Simon，以及他們的同事和學生開創了這種方法並繼續追求它。Newell 等人於 1957 年首次提出 GPS [18]。最初的想法是將某個通用類別的問題表示為透過一組允許的規則將一個表達式轉換為另一個表達式的問題。甚至在 [20] 中提出，改進 GPS 可以被視為這類問題。在我看來，GPS 作為通用問題求解器並不成功，因為問題通常不採取這種形式，而且問題解決和達成目標所需的大部分知識不能簡單地以轉換表達式的規則形式表示。然而，GPS 是第一個將目標和子目標的問題解決結構與特定領域分開的系統。如果 GPS 最終證明具有真正的普遍性，也許 Newell 和 Simon 關於 AI 快速成功的預測就已經實現了。Newell 目前的通用問題表示候選方案 [22] 是 SOAR，據我理解，它關注於將一個狀態轉換為另一個狀態，其中狀態不必由表達式表示。

## 產生式系統

第一個產生式系統是由 Newell 和 Simon 在 1950 年代完成的，這個想法在 [21] 中有記載。透過對所有類型的問題使用相同的目標尋求機制，僅改變特定的產生式規則，實現了一種普遍性。早期的產生式系統已經發展成為當前激增的專家系統殼層。

產生式系統以事實和規則的形式表示知識，並且規則之間幾乎總是有明顯的語法區別。事實通常對應於邏輯公式的基實例，也就是說，它們對應於應用於常數表達式的謂詞符號。與基於邏輯的系統不同，這些事實不包含變數或量詞。新的事實透過推論、觀察和使用者輸入產生。變數保留給規則使用，規則通常採用模式-動作的形式。規則由程式設計師或「知識工程師」放入系統中，在大多數系統中不能透過系統的操作產生。作為接受這些限制的交換，產生式系統程式設計師得到一個相對快速的程式。

產生式系統程式很少使用領域的基礎知識。例如，MYCIN [2] 有許多關於如何根據症狀和實驗室測試結果推斷哪種細菌引起疾病的規則。然而，它的形式體系無法表達細菌是在體內生長的有機體這一事實。事實上，MYCIN 無法表示隨時間發生的過程，儘管其他產生式系統可以表示大約在下一節將描述的情境演算層級上的過程。

產生式系統模式匹配的結果是用常數替換規則模式部分中的變數。因此，產生式系統不推斷一般命題。例如，考慮一個定義：如果容器對細菌進入是密封的，並且其中所有的細菌都死了，那麼該容器是無菌的。產生式系統（或邏輯程式）只能透過用特定的細菌替換變數來使用這個事實。因此，它無法推斷加熱一個密封容器會使其無菌，即使已知加熱的細菌會死亡，因為它無法對容器中未枚舉的細菌集合進行推理。

這些問題在 [14] 中有進一步討論。

## 在邏輯中表達知識

在 1958 年，在我看來，行為上的小修改最常能表示為對世界信念的小修改，這需要一個能明確表示信念的系統。如果希望一台機器能夠發現一個抽象概念，那麼最有可能的是該機器必須能夠以某種相對簡單的方式來表示這個抽象概念。[11, p. 78]1960 年提高普遍性的想法是使用邏輯以一種獨立於事實後續可能被使用的方式來表達事實。當時看起來是這樣，現在仍然如此，即人類主要透過陳述句而非程式語言進行交流，這是出於良好的客觀原因，無論溝通者是人類、來自南門二的生物，還是電腦程式，這些原因都適用。此外，陳述性資訊的優勢也適用於內部表示。陳述性資訊的優勢在於其普遍性。兩個物體碰撞時會發出噪音這個事實，可以在特定情況下用來製造噪音、避免製造噪音、解釋噪音，或解釋沒有噪音。（我想那些車沒有相撞，因為雖然我聽到了剎車的尖叫聲，但我沒有聽到撞擊聲。）一旦決定建立一個以陳述方式表示資訊的 AI 系統，仍然需要決定允許哪種陳述語言。最簡單的系統只允許應用於常數符號的常數謂詞，例如，on(Block1, Block2)。接下來，可以允許由函式符號、常數和謂詞符號構成的任意常數項，例如，location(Block1)=top(Block2)。Prolog 資料庫允許包含自由變數的任意 Horn 子句，例如，P(x, y) A Q(y, z) ⊃ R(x, z)，用標準邏輯符號表示 Prolog。除此之外還有完整的一階邏輯，包括存在量詞和全稱量詞以及任意的一階公式。在一階邏輯內部，一個理論的表達能力取決於變數允許的範圍域。重要的表達能力來自使用集合論，它包含用於理論中任何對象集合的表達式。

表達能力的每一次增強都需要付出推理和問題解決程式複雜性增加的代價。換句話說，接受對陳述資訊表達能力的限制，允許簡化搜尋過程。Prolog 在這個連續體中代表了一個局部最優點，因為 Horn 子句具有中等的表達能力，但可以由邏輯問題求解器直接解釋。

一個通常被接受的主要限制是將新事實的推導限制在沒有變數的公式，也就是說，用常數替換變數然後進行命題推理。看來大多數人類日常活動只涉及這樣的推理。原則上，Prolog 稍微超出了這一點，因為 Prolog 程式找到的作為變數值的表達式本身可以包含自由變數。然而，這個功能很少使用，除非用於中間結果。

如果沒有比 Prolog 所允許的更多謂詞演算，就無法完成的是全稱泛化。考慮罐頭製作的原理。我們說一個容器是無菌的，如果它是密封的並且裡面所有的細菌都死了。這可以表示為 Prolog 程式的一個片段，如下所示：

sterile(X) :- sealed(X), not alive-bacterium(Y, X).alive-bacterium(Y, X) :- in(Y, X), bacterium(Y), alive(Y).然而，一個直接包含這個片段的 Prolog 程式只能透過單獨殺死每個細菌來使容器無菌，並且需要程式的其他部分連續生成細菌的名稱。它不能被用來發現或合理化罐頭製作——密封容器然後加熱以一次性殺死所有細菌。合理化罐頭製作的推理涉及以一種本質的方式使用量詞。我個人的觀點是，推理和問題解決程式最終將不得不允許量詞和集合的充分使用，並且擁有足夠強大的控制方法來使用它們而不會導致組合爆炸。

雖然 1958 年的想法很受歡迎，但在接下來的幾年裡，很少有人嘗試將其體現在程式中，主要的一個是 Black 在 1964 年的哈佛大學博士論文。我把大部分時間花在我認為是初步的項目上，主要是 LISP。我沒有嘗試實現的主要原因是我首先想學習如何用邏輯表達常識知識。這仍然是我的目標。如果追求非邏輯方法的人在實現普遍性方面取得顯著成功，我可能會不再追求它。McCarthy 和 Hayes [12] 區分了 AI 問題的認識論和啟發式方面，並斷言普遍性更容易在認識論上研究。區別在於，當可用的事實可以推斷出某個策略適合達成目標時，認識論就完成了，而啟發式問題則涉及找到合適策略的搜索過程。[11] 中隱含了一個通用目的、常識資料庫的想法。人類擁有的常識資訊將被寫成邏輯語句並包含在資料庫中。任何尋求目標的程式都可以查詢資料庫以獲取決定如何實現其目標所需的事實。資料庫中特別突出的是關於行動效果的事實。被廣泛研究的例子是關於機器人試圖將物體從一個位置移動到另一個位置的效果的事實集合。這在 1960 年代引出了情境演算 [12]，旨在提供一種獨立於問題表達行動後果的方式。

情境演算的基本形式是s' = result(e, s),它斷言 s' 是事件 e 在情境 s 中發生後產生的情境。以下是一些用於移動和繪畫積木的情境演算公理。

限定的行動結果公理∀ x l s.clear(top(x), s) ∧ clear(l, s) ∧¬ tooheavy(x) ⊃ loc(x, result(move(x, l), s))= l.∀ x c s.color(x, result(paint(x, c), s))= c.

框架公理∀ x y l s.color(y, result(move(x, l), s))= color(y, s).∀ x y l s.y ≠ x ⊃ loc(y, result(move(x, l), s))=loc(y, s).∀ x y c s.loc(x, result(paint(y, c), s)) = loc(x, s).∀ x y c s.y ≠ x ⊃ color(x, result(paint(y, c), s)) =color(x, s).

請注意，對行動執行的所有限定條件都在前提中明確說明，並且關於當一個行動執行時什麼不變的陳述（稱為框架公理）被明確包含在內。沒有這些陳述，就不可能推斷出關於 result(e2, result(el, s)) 的太多資訊，因為我們不知道事件 e2 要產生其預期結果的前提是否在 result(el, s) 中得到滿足。

再者，請注意情境演算僅適用於對離散事件進行推理是合理的情況，每個事件都會導致一個新的完整情境。連續事件和並行事件不包括在內。

不幸的是，即使對於滿足其限制的問題，以提議的方式使用情境演算也不是很可行。首先，使用通用定理證明器使得程式運行太慢，因為 1969 年的定理證明器 [9] 沒有控制搜索的方法。這導致了 STRIPS [6] 的產生，它將邏輯的使用減少到在一個情境內進行推理。不幸的是，STRIPS 的形式化比完整的情境演算要特殊得多。公理中包含的事實必須被精細地選擇，以避免由於未能刪除在行動產生的情境中不再為真的語句而引入矛盾。

## 非單調性

情境演算公理的第二個問題是它們再次不夠通用。這是限定問題（qualification problem），直到 1970 年代末才發現可能的解決方法。考慮在一個常識資料庫中加入一個斷言鳥會飛的公理。顯然，這個公理必須以某種方式加以限定，因為企鵝、死鳥以及腳被包在混凝土裡的鳥都不能飛。仔細構建公理可能會成功包含企鵝和死鳥的例外，但顯然我們可以想出任意多的額外例外，比如腳被包在混凝土裡的鳥。形式化的非單調推理（見 [4], [15]-[17], 和 [23]）提供了一種形式化的方式來說明鳥會飛，除非存在異常情況，並且進行推理時，只考慮那些其存在性能從被考慮的事實中推導出來的異常情況。

非單調性大大增加了在情境演算中表達關於事件影響的通用知識的可能性。它也提供了一種解決框架問題（frame problem）的方法，這是 [12] 中已經指出的另一個普遍性的障礙。框架問題（這個術語有不同的用法，但我首先使用它）發生在有多個可用行動，每個行動都會改變情境的某些特徵時。不知何故，必須說明一個行動只改變它直接涉及的情境特徵。當有一組固定的行動和特徵時，可以明確說明哪些特徵不受某個行動的影響，即使這可能需要很多公理。然而，如果我們設想可以向資料庫添加額外的情境特徵和額外的行動，我們就面臨著行動的公理化永遠無法完成的問題。McCarthy [16] 指出了如何使用限制推論 (circumscription) 來處理這個問題，但 Lifschitz [10] 已經表明限制推論需要改進，並為此提出了建議。以下是一些使用取自 [16] 的限制推論來移動和繪畫積木的情境演算公理。

關於位置和移動物體效果的公理∀ x e s. ¬ab(aspect1(x, e, s)) ⊃ loc(x, result(e, s))=loc(x, s).∀ x l s. ab(aspect1(x, move(x, l), s)).∀ x l s. ¬ ab(aspect3(x, l, s)) ⊃ loc(x, result(move(x, l), s)) = l.

關於顏色和繪畫的公理∀ x e s. ¬ ab(aspect2(x, e, s)) ⊃ color(x, result(e, s))=color(x, s).∀ x c s. ab(aspect2(x, paint(x, c), s)).∀ x c s. ¬ ab(aspect4(x, c, s)) ⊃ color(x, result(paint(x, c), s)) = c.

這處理了限定問題，因為任何可以想像到的阻止移動或繪畫的條件都可以稍後添加，並斷言它們蘊含相應的 ab aspect...。它處理了框架問題，因為我們不必說移動不影響顏色，繪畫不影響位置。即使有了形式化的非單調推理，通用的常識資料庫似乎仍然難以捉摸。問題在於編寫滿足我們關於納入現象一般事實概念的公理。每當我們試探性地決定一些公理時，我們就能想到它們不適用的情境，需要進行泛化。此外，想到的困難往往是臨時性的，就像那隻腳被包在混凝土裡的鳥一樣。

## 具體化 (Reification)

關於知識、信念或目標的推理需要擴展被推理對象的領域。例如，一個在目標上進行反向鏈接的程式直接將它們用作語句：on(Block1, Block2)；也就是說，符號 on 被用作語言的謂詞常數。然而，一個想要直接說明 on(Block1, Block2) 應該推遲到 on(Block2, Block3) 被達成之後的程式，需要一個像 precedes(on(Block2, Block3), on(Block1, Block2)) 這樣的語句，而如果這要成為一個一階邏輯的語句，那麼符號 on 必須被視為函式符號，而 on(Block1, Block2) 被視為一階語言中的一個對象。這個將語句和其他實體轉化為對象的過程稱為具體化。這對於表達能力是必要的，但同樣會導致推理的複雜化。這在 [13] 中有討論。

## 形式化脈絡的概念

每當我們寫下一條公理，批評者可以說這條公理只在某個特定的脈絡下為真。只要有一點巧思，批評者通常可以設計出一個更普遍的脈絡，在該脈絡下公理的精確形式並不成立。觀察反映在語言中的人類推理強調了這一點。考慮將「on」公理化，以便從句子「書在桌子上」所表達的信息中得出適當的結論。批評者可能會提議糾纏「on」的精確含義，發明關於書和桌子之間能有什麼東西，或者在太空船中需要多少重力才能使用「on」這個詞，以及離心力是否算數的難題。因此，我們遇到了關於概念在完全普遍性下的含義的蘇格拉底式難題，並遇到了生活中從未出現的例子。根本就不存在一個最普遍的脈絡。反過來，如果我們在相當高的普遍性層級上進行公理化，這些公理往往比在特殊情況下方便使用的要長。因此，人類發現說「書在桌子上」很有用，省略了對時間和具體哪本書、哪張桌子的精確標識。無論通用常識知識是用邏輯、程式還是其他形式主義表達，都會出現這種關於要多麼普遍的問題。（有些人提議知識在內部僅以例子的形式表達，但使用類比和相似性的強大機制允許它們更普遍地使用。我祝願他們在為這些機制制定精確提議方面好運。）一個可能的出路是將脈絡的概念形式化，並將其與非單調推理的限制推論方法相結合。我們在公理中的函式和謂詞中添加一個脈絡參數。每個公理都對某個特定的脈絡做出斷言。進一步的公理告訴我們，事實會被更受限的脈絡繼承，除非有例外被斷言。每個斷言也被非單調地假定適用於任何特定的更普遍的脈絡，但同樣存在例外。例如，關於鳥飛行的規則隱含地假設有大氣層可以飛行。在一個更普遍的脈絡中，這可能不被假設。還有待確定向更普遍脈絡的繼承與向更具體脈絡的繼承有何不同。

假設每當一個句子 p 出現在電腦的記憶體中時，我們都將其視為在特定脈絡下，並且是句子 holds(p, C) 的縮寫，其中 C 是脈絡的名稱。有些脈絡非常具體，例如 Watson 在 Sherlock Holmes 故事的脈絡下是醫生，而在一個關於心理學歷史的悲劇歌劇中是男中音心理學家。存在一個關係 c1 < c2，表示脈絡 c2 比脈絡 c1 更普遍。我們允許像 holds(c1 < c2, c0) 這樣的句子，這樣即使是關聯脈絡的陳述也可以有脈絡。這個理論不會提供任何「最普遍的脈絡」，就像 Zermelo-Frankel 集合論不提供最普遍的集合一樣。一個使用脈絡的邏輯系統可能會提供進入和離開脈絡的操作，產生我們可能稱之為超自然演繹的東西，允許像這樣的推理序列：

holds(p, C)
ENTER C
P
q
LEAVE C
holds(q, C). 

這類似於通常的邏輯自然演繹系統，但由於超出本講座範圍的原因，將脈絡等同於假設集合——即使是無限的假設集合——可能是不正確的。所有這些都令人不悅地模糊，但比 1971 年能說的要多得多。